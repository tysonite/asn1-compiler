/* Generated By:JJTree&JavaCC: Do not edit this line. AsnParser.java */
package parser;

import java.io.*;
import java.util.*;
import gen.*;

public class AsnParser/*@bgen(jjtree)*/implements AsnParserTreeConstants, AsnParserConstants {/*@bgen(jjtree)*/
  protected static JJTAsnParserState jjtree = new JJTAsnParserState();/**
	 * The base package name for the generated classes.
	 *<p>
	 * This package is prepended to the module name to get the final package
	 * name for the generated classes.
	 *<p>
	 * For example, if "-p foo.bar" is given on the command line, the classes
	 * generated from the module X509 will be in the package foo.bar.x509.
	 */
        public static String outputPackage;

        /**
	 * The name of the directory to create for the package.
	 */
        public static String packageDirectory;

        /**
	 * The name of the final output directory.
	 *
	 * This is the base output directory plus the package name.
	 */
        public static String outputDirectory;

        /**
	 * The directory where the classes are created.
	 *<p>
	 * This is the top level directory. Each of the directories necessary
	 * for the packages are created under this directory.
	 *<p>
	 * The default is the current directory.
	 */
        public static String directory;

        public static void main(String args[]) throws ParseException
        {
                boolean showUsage = true;

                AsnParser parser;
                try
                {
                        int i;
                        for(i = 0; i < args.length; i++)
                        {
                                if(args[i].equals("-p"))
                                {
                                        i++;
                                        if(i >= args.length)
                                        {
                                                usage();
                                                System.exit(1);
                                        }

                                        outputPackage = args[i];
                                        continue;
                                }

                                if(args[i].equals("-d"))
                                {
                                        i++;
                                        if(i >= args.length)
                                        {
                                                usage();
                                                System.exit(1);
                                        }

                                        directory = args[i];
                                        continue;
                                }

                                parser = new AsnParser(new FileInputStream(args[i]));
                                parser.Input();
                                System.out.println("ASN.1 file parsed successfully.");

                                if(directory != null)
                                {
                                        File outputDir = new File(directory);
                                        if(outputDir.exists() == true)
                                        {
                                                if(outputDir.isDirectory() != true)
                                                {
                                                        System.err.println(directory + " is not a directory, cannot continue");
                                                        System.exit(1);
                                                }
                                        }
                                        else
                                        {
                                                boolean x = outputDir.mkdirs();
                                                if(x != true)
                                                {
                                                        System.err.println("could not create directory " + directory + ", cannot continue");
                                                        System.exit(1);
                                                }
                                        }
                                }

                                if(outputPackage != null)
                                {
                                        packageDirectory = new String(outputPackage);
                                        String fileSeparator = System.getProperty("file.separator");
                                        char[] fileSepArray = fileSeparator.toCharArray();
                                        if(fileSepArray.length == 1)
                                                packageDirectory = packageDirectory.replace('.', fileSepArray[0]);
                                        //else
                                                // don't know what to do in this case!

                                        outputDirectory = new String(directory + fileSeparator + packageDirectory);
                                        File f = new File(outputDirectory);
                                        boolean x = f.mkdirs();
                                        if(x != true)
                                        {
                                                System.err.println("could not create directory " + outputDirectory + ", cannot continue");
                                                System.exit(1);
                                        }
                                }
                                else
                                        outputDirectory = directory;

                                SimpleNode root = (SimpleNode)jjtree.rootNode();
                                root.dump("\u005ct");

            CPPCodeGenerator generator = new CPPCodeGenerator(root, outputDirectory);
            generator.generate(null);

                                showUsage = false;
                        }
                }
                catch(Exception e)
                {
                        e.printStackTrace();
                }

                if(showUsage == true)
                {
                        usage();
                        System.exit(1);
                }
        }

        static void
        usage()
        {
                System.out.println("arc - ASN.1 compiler");
                System.out.println("Copyright 1999 FORGE Research Pty Ltd\u005cn");
                System.out.println("usage: java AsnParser [-d directory] [-p package] source files...");
        }

   static void lookForAssignment(Node n) {
      int numChildren = n.jjtGetNumChildren();
      for (int i = 0; i < numChildren; i++) {
         SimpleNode node = (SimpleNode) n.jjtGetChild(i);
         if (node instanceof ASTTypeAssignment) {
            //new TypeGenerator().generate((ASTTypeAssignment) node);
         } else {
            lookForAssignment(node);
         }
      }
   }

        static String
        returnRecursive(Node n)
        {
                String s = new String("");
                return s;
        }

   public static void jjtreeOpenNodeScope(Node n) {
      ((SimpleNode) n).setFirstToken(getToken(1));
   }

   public static void jjtreeCloseNodeScope(Node n) {
      ((SimpleNode) n).setLastToken(getToken(0));
   }

        private static String usefulTypes[] = {
                "GraphicString",  "NumericString", "PrintableString",
                "TeletexString", "T61String", "VideotexString", "IA5String",
                "VisibleString", "ISO646String", "GeneralizedTime", "UniversalString", "BMPString" };

  static final public void Input() throws ParseException {
                /*@bgen(jjtree) Input */
  ASTInput jjtn000 = new ASTInput(JJTINPUT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      label_1:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case UCASEFIRST_IDENT_TKN:
          ;
          break;
        default:
          jj_la1[0] = jj_gen;
          break label_1;
        }
        ModuleDefinition();
      }
    } catch (Throwable jjte000) {
   if (jjtc000) {
     jjtree.clearNodeScope(jjtn000);
     jjtc000 = false;
   } else {
     jjtree.popNode();
   }
   if (jjte000 instanceof RuntimeException) {
     {if (true) throw (RuntimeException)jjte000;}
   }
   if (jjte000 instanceof ParseException) {
     {if (true) throw (ParseException)jjte000;}
   }
   {if (true) throw (Error)jjte000;}
    } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
     jjtreeCloseNodeScope(jjtn000);
   }
    }
  }

  static final public void ModuleDefinition() throws ParseException {
 /*@bgen(jjtree) ModuleDefinition */
   ASTModuleDefinition jjtn000 = new ASTModuleDefinition(JJTMODULEDEFINITION);
   boolean jjtc000 = true;
   jjtree.openNodeScope(jjtn000);
   jjtreeOpenNodeScope(jjtn000);int tag;
    try {
      ModuleIdentifier();
      jj_consume_token(DEFINITIONS_TKN);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IMPLICIT_TKN:
      case EXPLICIT_TKN:
      case AUTOMATIC_TKN:
        tag = TagDefault();
         jjtn000.setTag(tag);
        break;
      default:
        jj_la1[1] = jj_gen;
        ;
      }
      jj_consume_token(GETS_TKN);
      jj_consume_token(BEGIN_TKN);
      ModuleBody();
      jj_consume_token(END_TKN);
    } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       {if (true) throw (RuntimeException)jjte000;}
     }
     if (jjte000 instanceof ParseException) {
       {if (true) throw (ParseException)jjte000;}
     }
     {if (true) throw (Error)jjte000;}
    } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
       jjtreeCloseNodeScope(jjtn000);
     }
    }
  }

  static final public int TagDefault() throws ParseException {
 /*@bgen(jjtree) TagDefault */
   ASTTagDefault jjtn000 = new ASTTagDefault(JJTTAGDEFAULT);
   boolean jjtc000 = true;
   jjtree.openNodeScope(jjtn000);
   jjtreeOpenNodeScope(jjtn000);int tag;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EXPLICIT_TKN:
        jj_consume_token(EXPLICIT_TKN);
                     tag = ASTModuleDefinition.EXPLICIT;
        break;
      case IMPLICIT_TKN:
        jj_consume_token(IMPLICIT_TKN);
                     tag = ASTModuleDefinition.IMPLICIT;
        break;
      case AUTOMATIC_TKN:
        jj_consume_token(AUTOMATIC_TKN);
                      tag = ASTModuleDefinition.AUTOMATIC;
        break;
      default:
        jj_la1[2] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jj_consume_token(TAGS_TKN);
     jjtree.closeNodeScope(jjtn000, true);
     jjtc000 = false;
     jjtreeCloseNodeScope(jjtn000);
      {if (true) return tag;}
    } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
       jjtreeCloseNodeScope(jjtn000);
     }
    }
    throw new Error("Missing return statement in function");
  }

  static final public void ModuleIdentifier() throws ParseException {
                           /*@bgen(jjtree) ModuleIdentifier */
  ASTModuleIdentifier jjtn000 = new ASTModuleIdentifier(JJTMODULEIDENTIFIER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      modulereference();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LEFTBRACE_TKN:
        AssignedIdentifier();
        break;
      default:
        jj_la1[3] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       {if (true) throw (RuntimeException)jjte000;}
     }
     if (jjte000 instanceof ParseException) {
       {if (true) throw (ParseException)jjte000;}
     }
     {if (true) throw (Error)jjte000;}
    } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
       jjtreeCloseNodeScope(jjtn000);
     }
    }
  }

  static final public void AssignedIdentifier() throws ParseException {
                             /*@bgen(jjtree) AssignedIdentifier */
  ASTAssignedIdentifier jjtn000 = new ASTAssignedIdentifier(JJTASSIGNEDIDENTIFIER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      ObjectIdentifierValue();
    } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       {if (true) throw (RuntimeException)jjte000;}
     }
     if (jjte000 instanceof ParseException) {
       {if (true) throw (ParseException)jjte000;}
     }
     {if (true) throw (Error)jjte000;}
    } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
       jjtreeCloseNodeScope(jjtn000);
     }
    }
  }

  static final public void ModuleBody() throws ParseException {
                     /*@bgen(jjtree) ModuleBody */
  ASTModuleBody jjtn000 = new ASTModuleBody(JJTMODULEBODY);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EXPORTS_TKN:
        Exports();
        break;
      default:
        jj_la1[4] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IMPORTS_TKN:
        Imports();
        break;
      default:
        jj_la1[5] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OBJECTTYPE_TKN:
      case TC_TKN:
      case LCASEFIRST_IDENT_TKN:
      case UCASEFIRST_IDENT_TKN:
        AssignmentList();
        break;
      default:
        jj_la1[6] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }

  static final public void Exports() throws ParseException {
                  /*@bgen(jjtree) Exports */
  ASTExports jjtn000 = new ASTExports(JJTEXPORTS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(EXPORTS_TKN);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OBJECTTYPE_TKN:
      case TC_TKN:
      case LCASEFIRST_IDENT_TKN:
      case UCASEFIRST_IDENT_TKN:
        SymbolsExported();
        break;
      default:
        jj_la1[7] = jj_gen;
        ;
      }
      jj_consume_token(SEMI_COLON_TKN);
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }

  static final public void SymbolsExported() throws ParseException {
                          /*@bgen(jjtree) SymbolsExported */
  ASTSymbolsExported jjtn000 = new ASTSymbolsExported(JJTSYMBOLSEXPORTED);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      ExportSymbolList();
    } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       {if (true) throw (RuntimeException)jjte000;}
     }
     if (jjte000 instanceof ParseException) {
       {if (true) throw (ParseException)jjte000;}
     }
     {if (true) throw (Error)jjte000;}
    } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
       jjtreeCloseNodeScope(jjtn000);
     }
    }
  }

  static final public void ExportSymbolList() throws ParseException {
                           /*@bgen(jjtree) ExportSymbolList */
  ASTExportSymbolList jjtn000 = new ASTExportSymbolList(JJTEXPORTSYMBOLLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      Symbol();
      label_2:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA_TKN:
          ;
          break;
        default:
          jj_la1[8] = jj_gen;
          break label_2;
        }
        jj_consume_token(COMMA_TKN);
        Symbol();
      }
    } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       {if (true) throw (RuntimeException)jjte000;}
     }
     if (jjte000 instanceof ParseException) {
       {if (true) throw (ParseException)jjte000;}
     }
     {if (true) throw (Error)jjte000;}
    } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
       jjtreeCloseNodeScope(jjtn000);
     }
    }
  }

  static final public void Imports() throws ParseException {
                  /*@bgen(jjtree) Imports */
  ASTImports jjtn000 = new ASTImports(JJTIMPORTS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(IMPORTS_TKN);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OBJECTTYPE_TKN:
      case TC_TKN:
      case LCASEFIRST_IDENT_TKN:
      case UCASEFIRST_IDENT_TKN:
        SymbolsImported();
        break;
      default:
        jj_la1[9] = jj_gen;
        ;
      }
      jj_consume_token(SEMI_COLON_TKN);
    } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       {if (true) throw (RuntimeException)jjte000;}
     }
     if (jjte000 instanceof ParseException) {
       {if (true) throw (ParseException)jjte000;}
     }
     {if (true) throw (Error)jjte000;}
    } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
       jjtreeCloseNodeScope(jjtn000);
     }
    }
  }

  static final public void SymbolsImported() throws ParseException {
                          /*@bgen(jjtree) SymbolsImported */
  ASTSymbolsImported jjtn000 = new ASTSymbolsImported(JJTSYMBOLSIMPORTED);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      SymbolsFromModuleList();
    } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       {if (true) throw (RuntimeException)jjte000;}
     }
     if (jjte000 instanceof ParseException) {
       {if (true) throw (ParseException)jjte000;}
     }
     {if (true) throw (Error)jjte000;}
    } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
       jjtreeCloseNodeScope(jjtn000);
     }
    }
  }

  static final public void SymbolsFromModuleList() throws ParseException {
                                /*@bgen(jjtree) SymbolsFromModuleList */
  ASTSymbolsFromModuleList jjtn000 = new ASTSymbolsFromModuleList(JJTSYMBOLSFROMMODULELIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      SymbolsFromModule();
      label_3:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case OBJECTTYPE_TKN:
        case TC_TKN:
        case LCASEFIRST_IDENT_TKN:
        case UCASEFIRST_IDENT_TKN:
          ;
          break;
        default:
          jj_la1[10] = jj_gen;
          break label_3;
        }
        SymbolsFromModule();
      }
    } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       {if (true) throw (RuntimeException)jjte000;}
     }
     if (jjte000 instanceof ParseException) {
       {if (true) throw (ParseException)jjte000;}
     }
     {if (true) throw (Error)jjte000;}
    } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
       jjtreeCloseNodeScope(jjtn000);
     }
    }
  }

  static final public void SymbolsFromModule() throws ParseException {
                            /*@bgen(jjtree) SymbolsFromModule */
                             ASTSymbolsFromModule jjtn000 = new ASTSymbolsFromModule(JJTSYMBOLSFROMMODULE);
                             boolean jjtc000 = true;
                             jjtree.openNodeScope(jjtn000);
                             jjtreeOpenNodeScope(jjtn000);String module;
    try {
      SymbolList();
      jj_consume_token(FROM_TKN);
      ModuleIdentifier();
    } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       {if (true) throw (RuntimeException)jjte000;}
     }
     if (jjte000 instanceof ParseException) {
       {if (true) throw (ParseException)jjte000;}
     }
     {if (true) throw (Error)jjte000;}
    } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
       jjtreeCloseNodeScope(jjtn000);
     }
    }
  }

  static final public void SymbolList() throws ParseException {
                     /*@bgen(jjtree) SymbolList */
  ASTSymbolList jjtn000 = new ASTSymbolList(JJTSYMBOLLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      Symbol();
      label_4:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA_TKN:
          ;
          break;
        default:
          jj_la1[11] = jj_gen;
          break label_4;
        }
        jj_consume_token(COMMA_TKN);
        Symbol();
      }
    } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       {if (true) throw (RuntimeException)jjte000;}
     }
     if (jjte000 instanceof ParseException) {
       {if (true) throw (ParseException)jjte000;}
     }
     {if (true) throw (Error)jjte000;}
    } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
       jjtreeCloseNodeScope(jjtn000);
     }
    }
  }

  static final public void Symbol() throws ParseException {
                 /*@bgen(jjtree) Symbol */
  ASTSymbol jjtn000 = new ASTSymbol(JJTSYMBOL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case UCASEFIRST_IDENT_TKN:
        typereference();
        break;
      case LCASEFIRST_IDENT_TKN:
        identifier();
        break;
      case OBJECTTYPE_TKN:
      case TC_TKN:
        DefinedMacroName();
        break;
      default:
        jj_la1[12] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       {if (true) throw (RuntimeException)jjte000;}
     }
     if (jjte000 instanceof ParseException) {
       {if (true) throw (ParseException)jjte000;}
     }
     {if (true) throw (Error)jjte000;}
    } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
       jjtreeCloseNodeScope(jjtn000);
     }
    }
  }

  static final public void AssignmentList() throws ParseException {
                         /*@bgen(jjtree) AssignmentList */
  ASTAssignmentList jjtn000 = new ASTAssignmentList(JJTASSIGNMENTLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      Assignment();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SEMI_COLON_TKN:
        jj_consume_token(SEMI_COLON_TKN);
        break;
      default:
        jj_la1[13] = jj_gen;
        ;
      }
      label_5:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case OBJECTTYPE_TKN:
        case TC_TKN:
        case LCASEFIRST_IDENT_TKN:
        case UCASEFIRST_IDENT_TKN:
          ;
          break;
        default:
          jj_la1[14] = jj_gen;
          break label_5;
        }
        Assignment();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SEMI_COLON_TKN:
          jj_consume_token(SEMI_COLON_TKN);
          break;
        default:
          jj_la1[15] = jj_gen;
          ;
        }
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }

  static final public void Assignment() throws ParseException {
    if (jj_2_1(2)) {
      MacroDefinition();
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case UCASEFIRST_IDENT_TKN:
        TypeAssignment();
        break;
      case LCASEFIRST_IDENT_TKN:
        ValueAssignment();
        break;
      default:
        jj_la1[16] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }

  static final public void MacroDefinition() throws ParseException {
                          /*@bgen(jjtree) MacroDefinition */
  ASTMacroDefinition jjtn000 = new ASTMacroDefinition(JJTMACRODEFINITION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TC_TKN:
        jj_consume_token(TC_TKN);
        break;
      case OBJECTTYPE_TKN:
        jj_consume_token(OBJECTTYPE_TKN);
        break;
      case UCASEFIRST_IDENT_TKN:
        typereference();
        break;
      default:
        jj_la1[17] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jj_consume_token(MACRO_TKN);
      jj_consume_token(GETS_TKN);
      jj_consume_token(BEGIN_TKN);
      MacroBody();
      jj_consume_token(END_TKN);
    } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       {if (true) throw (RuntimeException)jjte000;}
     }
     if (jjte000 instanceof ParseException) {
       {if (true) throw (ParseException)jjte000;}
     }
     {if (true) throw (Error)jjte000;}
    } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
       jjtreeCloseNodeScope(jjtn000);
     }
    }
  }

  static void MacroBody() throws ParseException {
                  /*@bgen(jjtree) MacroBody */
ASTMacroBody jjtn000 = new ASTMacroBody(JJTMACROBODY);
boolean jjtc000 = true;
jjtree.openNodeScope(jjtn000);
jjtreeOpenNodeScope(jjtn000);
try {Token tok;
  int nesting = 1;
  while (true) {
    tok = getToken(1);
    if (tok.kind == END_TKN) {
        break;
    }
    tok = getNextToken();
  }/*@bgen(jjtree)*/
} finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
    jjtreeCloseNodeScope(jjtn000);
  }
}
  }

  static final public void MacroReference() throws ParseException {
                         /*@bgen(jjtree) MacroReference */
  ASTMacroReference jjtn000 = new ASTMacroReference(JJTMACROREFERENCE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case UCASEFIRST_IDENT_TKN:
        typereference();
        break;
      case OBJECTTYPE_TKN:
      case TC_TKN:
        DefinedMacroName();
        break;
      default:
        jj_la1[18] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       {if (true) throw (RuntimeException)jjte000;}
     }
     if (jjte000 instanceof ParseException) {
       {if (true) throw (ParseException)jjte000;}
     }
     {if (true) throw (Error)jjte000;}
    } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
       jjtreeCloseNodeScope(jjtn000);
     }
    }
  }

  static final public void TypeAssignment() throws ParseException {
 /*@bgen(jjtree) TypeAssignment */
   ASTTypeAssignment jjtn000 = new ASTTypeAssignment(JJTTYPEASSIGNMENT);
   boolean jjtc000 = true;
   jjtree.openNodeScope(jjtn000);
   jjtreeOpenNodeScope(jjtn000);int type;
    try {
      typereference();
      jj_consume_token(GETS_TKN);
      type = GlobalType();
        jjtree.closeNodeScope(jjtn000, true);
        jjtc000 = false;
        jjtreeCloseNodeScope(jjtn000);
         jjtn000.setAssignment(type);
    } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       {if (true) throw (RuntimeException)jjte000;}
     }
     if (jjte000 instanceof ParseException) {
       {if (true) throw (ParseException)jjte000;}
     }
     {if (true) throw (Error)jjte000;}
    } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
       jjtreeCloseNodeScope(jjtn000);
     }
    }
  }

  static final public int GlobalType() throws ParseException {
   int type = -1;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OBJECT_IDENTIFIER_TKN:
    case LEFTBRACKET_TKN:
    case BOOLEAN_TKN:
    case INTEGER_TKN:
    case BIT_TKN:
    case OCTET_TKN:
    case NULL_TKN:
    case SEQUENCE_TKN:
    case SET_TKN:
    case CHOICE_TKN:
    case ANY_TKN:
    case ENUMERATED_TKN:
    case EXTERNAL_TKN:
    case REAL_TKN:
    case LCASEFIRST_IDENT_TKN:
    case UCASEFIRST_IDENT_TKN:
      type = Type();
      break;
    case OBJECTTYPE_TKN:
    case TC_TKN:
      DefinedMacroType();
      break;
    default:
      jj_la1[19] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
      {if (true) return type;}
    throw new Error("Missing return statement in function");
  }

  static final public int Type() throws ParseException {
                    int type = -1;
    if (jj_2_2(2)) {
      BuiltinType();
         type = ASTTypeAssignment.BUILTIN_ASSIGNMENT;
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case UCASEFIRST_IDENT_TKN:
        DefinedType();
         type = ASTTypeAssignment.DEFINED_ASSIGNMENT;
        break;
      default:
        jj_la1[20] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    if (jj_2_3(2)) {
      SubtypeSpec();
    } else {
      ;
    }
     {if (true) return type;}
    throw new Error("Missing return statement in function");
  }

  static final public void DefinedType() throws ParseException {
                      /*@bgen(jjtree) DefinedType */
  ASTDefinedType jjtn000 = new ASTDefinedType(JJTDEFINEDTYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      if (jj_2_4(2)) {
        modulereference();
        jj_consume_token(DOT_TKN);
      } else {
        ;
      }
      typereference();
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }

  static final public void BuiltinType() throws ParseException {
                      /*@bgen(jjtree) BuiltinType */
                       ASTBuiltinType jjtn000 = new ASTBuiltinType(JJTBUILTINTYPE);
                       boolean jjtc000 = true;
                       jjtree.openNodeScope(jjtn000);
                       jjtreeOpenNodeScope(jjtn000);int x;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INTEGER_TKN:
        IntegerType();
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                  jjtreeCloseNodeScope(jjtn000);
                  jjtn000.setType(0);
        break;
      case BIT_TKN:
        BitStringType();
                     jjtree.closeNodeScope(jjtn000, true);
                     jjtc000 = false;
                     jjtreeCloseNodeScope(jjtn000);
                     jjtn000.setType(1);
        break;
      default:
        jj_la1[21] = jj_gen;
        if (jj_2_5(2)) {
          x = SetOrSequenceType();
                                         jjtree.closeNodeScope(jjtn000, true);
                                         jjtc000 = false;
                                         jjtreeCloseNodeScope(jjtn000);
                                         jjtn000.setType(x);
        } else {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case SEQUENCE_TKN:
          case SET_TKN:
            x = SetOrSequenceOfType();
                              jjtree.closeNodeScope(jjtn000, true);
                              jjtc000 = false;
                              jjtreeCloseNodeScope(jjtn000);
                              jjtn000.setType(x);
            break;
          case CHOICE_TKN:
            ChoiceType();
                 jjtree.closeNodeScope(jjtn000, true);
                 jjtc000 = false;
                 jjtreeCloseNodeScope(jjtn000);
                 jjtn000.setType(6);
            break;
          case LCASEFIRST_IDENT_TKN:
            SelectionType();
                    jjtree.closeNodeScope(jjtn000, true);
                    jjtc000 = false;
                    jjtreeCloseNodeScope(jjtn000);
                    jjtn000.setType(7);
            break;
          case LEFTBRACKET_TKN:
            TaggedType();
                 jjtree.closeNodeScope(jjtn000, true);
                 jjtc000 = false;
                 jjtreeCloseNodeScope(jjtn000);
                 jjtn000.setType(8);
            break;
          case ANY_TKN:
            AnyType();
              jjtree.closeNodeScope(jjtn000, true);
              jjtc000 = false;
              jjtreeCloseNodeScope(jjtn000);
              jjtn000.setType(9);
            break;
          case ENUMERATED_TKN:
            EnumeratedType();
                     jjtree.closeNodeScope(jjtn000, true);
                     jjtc000 = false;
                     jjtreeCloseNodeScope(jjtn000);
                     jjtn000.setType(10);
            break;
          case OCTET_TKN:
            OctetStringType();
                      jjtree.closeNodeScope(jjtn000, true);
                      jjtc000 = false;
                      jjtreeCloseNodeScope(jjtn000);
                      jjtn000.setType(11);
            break;
          case OBJECT_IDENTIFIER_TKN:
            ObjectIdentifierType();
                           jjtree.closeNodeScope(jjtn000, true);
                           jjtc000 = false;
                           jjtreeCloseNodeScope(jjtn000);
                           jjtn000.setType(12);
            break;
          case REAL_TKN:
            jj_consume_token(REAL_TKN);
               jjtree.closeNodeScope(jjtn000, true);
               jjtc000 = false;
               jjtreeCloseNodeScope(jjtn000);
               jjtn000.setType(13);
            break;
          case BOOLEAN_TKN:
            BooleanType();
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                  jjtreeCloseNodeScope(jjtn000);
                  jjtn000.setType(14);
            break;
          case NULL_TKN:
            NullType();
               jjtree.closeNodeScope(jjtn000, true);
               jjtc000 = false;
               jjtreeCloseNodeScope(jjtn000);
               jjtn000.setType(15);
            break;
          case EXTERNAL_TKN:
            jj_consume_token(EXTERNAL_TKN);
                   jjtree.closeNodeScope(jjtn000, true);
                   jjtc000 = false;
                   jjtreeCloseNodeScope(jjtn000);
                   jjtn000.setType(16);
            break;
          default:
            jj_la1[22] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }

  static final public void NullType() throws ParseException {
                   /*@bgen(jjtree) NullType */
  ASTNullType jjtn000 = new ASTNullType(JJTNULLTYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(NULL_TKN);
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
    }
  }

  static final public void BooleanType() throws ParseException {
                      /*@bgen(jjtree) BooleanType */
  ASTBooleanType jjtn000 = new ASTBooleanType(JJTBOOLEANTYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(BOOLEAN_TKN);
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
    }
  }

  static final public void ObjectIdentifierType() throws ParseException {
                               /*@bgen(jjtree) ObjectIdentifierType */
  ASTObjectIdentifierType jjtn000 = new ASTObjectIdentifierType(JJTOBJECTIDENTIFIERTYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(OBJECT_IDENTIFIER_TKN);
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
    }
  }

  static final public void OctetStringType() throws ParseException {
                          /*@bgen(jjtree) OctetStringType */
  ASTOctetStringType jjtn000 = new ASTOctetStringType(JJTOCTETSTRINGTYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(OCTET_TKN);
      jj_consume_token(STRING_TKN);
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
    }
  }

  static final public void EnumeratedType() throws ParseException {
                         /*@bgen(jjtree) EnumeratedType */
  ASTEnumeratedType jjtn000 = new ASTEnumeratedType(JJTENUMERATEDTYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(ENUMERATED_TKN);
      jj_consume_token(LEFTBRACE_TKN);
      NamedNumberList();
      jj_consume_token(RIGHTBRACE_TKN);
    } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       {if (true) throw (RuntimeException)jjte000;}
     }
     if (jjte000 instanceof ParseException) {
       {if (true) throw (ParseException)jjte000;}
     }
     {if (true) throw (Error)jjte000;}
    } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
       jjtreeCloseNodeScope(jjtn000);
     }
    }
  }

  static final public void IntegerType() throws ParseException {
                      /*@bgen(jjtree) IntegerType */
  ASTIntegerType jjtn000 = new ASTIntegerType(JJTINTEGERTYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(INTEGER_TKN);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LEFTBRACE_TKN:
        jj_consume_token(LEFTBRACE_TKN);
        NamedNumberList();
        jj_consume_token(RIGHTBRACE_TKN);
        break;
      default:
        jj_la1[23] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
   if (jjtc000) {
     jjtree.clearNodeScope(jjtn000);
     jjtc000 = false;
   } else {
     jjtree.popNode();
   }
   if (jjte000 instanceof RuntimeException) {
     {if (true) throw (RuntimeException)jjte000;}
   }
   if (jjte000 instanceof ParseException) {
     {if (true) throw (ParseException)jjte000;}
   }
   {if (true) throw (Error)jjte000;}
    } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
     jjtreeCloseNodeScope(jjtn000);
   }
    }
  }

  static final public void BitStringType() throws ParseException {
                        /*@bgen(jjtree) BitStringType */
  ASTBitStringType jjtn000 = new ASTBitStringType(JJTBITSTRINGTYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(BIT_TKN);
      jj_consume_token(STRING_TKN);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LEFTBRACE_TKN:
        jj_consume_token(LEFTBRACE_TKN);
        NamedNumberList();
        jj_consume_token(RIGHTBRACE_TKN);
        break;
      default:
        jj_la1[24] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }

  static final public void NamedNumberList() throws ParseException {
                          /*@bgen(jjtree) NamedNumberList */
  ASTNamedNumberList jjtn000 = new ASTNamedNumberList(JJTNAMEDNUMBERLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      NamedNumber();
      label_6:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA_TKN:
          ;
          break;
        default:
          jj_la1[25] = jj_gen;
          break label_6;
        }
        jj_consume_token(COMMA_TKN);
        NamedNumber();
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }

  static final public void NamedNumber() throws ParseException {
                      /*@bgen(jjtree) NamedNumber */
  ASTNamedNumber jjtn000 = new ASTNamedNumber(JJTNAMEDNUMBER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      identifier();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LEFTPAREN_TKN:
        jj_consume_token(LEFTPAREN_TKN);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case NUMBER_ERANGE_TKN:
        case NUMBER_TKN:
        case MINUS_TKN:
          SignedNumber();
          break;
        case LCASEFIRST_IDENT_TKN:
        case UCASEFIRST_IDENT_TKN:
          DefinedValue();
          break;
        default:
          jj_la1[26] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        jj_consume_token(RIGHTPAREN_TKN);
        break;
      default:
        jj_la1[27] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }

  static final public void SignedNumber() throws ParseException {
 /*@bgen(jjtree) SignedNumber */
   ASTSignedNumber jjtn000 = new ASTSignedNumber(JJTSIGNEDNUMBER);
   boolean jjtc000 = true;
   jjtree.openNodeScope(jjtn000);
   jjtreeOpenNodeScope(jjtn000);Token m = null, n = null;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MINUS_TKN:
        m = jj_consume_token(MINUS_TKN);
        break;
      default:
        jj_la1[28] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case NUMBER_TKN:
        n = jj_consume_token(NUMBER_TKN);
        break;
      case NUMBER_ERANGE_TKN:
        n = jj_consume_token(NUMBER_ERANGE_TKN);
        break;
      default:
        jj_la1[29] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtreeCloseNodeScope(jjtn000);
     jjtn000.setNumber(Long.valueOf(((null != m) ? m.toString() : "") + n.toString()).longValue());
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }

/*
 * modified to return an integer differentiating sets and sequences
 */
  static final public int SetOrSequenceOfType() throws ParseException {
                             /*@bgen(jjtree) SetOrSequenceOfType */
                              ASTSetOrSequenceOfType jjtn000 = new ASTSetOrSequenceOfType(JJTSETORSEQUENCEOFTYPE);
                              boolean jjtc000 = true;
                              jjtree.openNodeScope(jjtn000);
                              jjtreeOpenNodeScope(jjtn000);int rc;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SET_TKN:
        jj_consume_token(SET_TKN);
                   rc = 4;
        break;
      case SEQUENCE_TKN:
        jj_consume_token(SEQUENCE_TKN);
                        rc = 5;
        break;
      default:
        jj_la1[30] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LEFTPAREN_TKN:
      case SIZE_TKN:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LEFTPAREN_TKN:
          jj_consume_token(LEFTPAREN_TKN);
          break;
        default:
          jj_la1[31] = jj_gen;
          ;
        }
        SizeConstraint();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case RIGHTPAREN_TKN:
          jj_consume_token(RIGHTPAREN_TKN);
          break;
        default:
          jj_la1[32] = jj_gen;
          ;
        }
        break;
      default:
        jj_la1[33] = jj_gen;
        ;
      }
      jj_consume_token(OF_TKN);
      Type();
             jjtree.closeNodeScope(jjtn000, true);
             jjtc000 = false;
             jjtreeCloseNodeScope(jjtn000);
             {if (true) return rc;}
    } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       {if (true) throw (RuntimeException)jjte000;}
     }
     if (jjte000 instanceof ParseException) {
       {if (true) throw (ParseException)jjte000;}
     }
     {if (true) throw (Error)jjte000;}
    } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
       jjtreeCloseNodeScope(jjtn000);
     }
    }
    throw new Error("Missing return statement in function");
  }

/*
 * modified to return an integer differentiating sets of and sequences of
 */
  static final public int SetOrSequenceType() throws ParseException {
                           /*@bgen(jjtree) SetOrSequenceType */
                            ASTSetOrSequenceType jjtn000 = new ASTSetOrSequenceType(JJTSETORSEQUENCETYPE);
                            boolean jjtc000 = true;
                            jjtree.openNodeScope(jjtn000);
                            jjtreeOpenNodeScope(jjtn000);int rc;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SET_TKN:
        jj_consume_token(SET_TKN);
                  jjtn000.setType(ASTSetOrSequenceType.SET); rc = 2;
        break;
      case SEQUENCE_TKN:
        jj_consume_token(SEQUENCE_TKN);
                       jjtn000.setType(ASTSetOrSequenceType.SEQUENCE); rc = 3;
        break;
      default:
        jj_la1[34] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jj_consume_token(LEFTBRACE_TKN);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OBJECT_IDENTIFIER_TKN:
      case LEFTBRACKET_TKN:
      case BOOLEAN_TKN:
      case INTEGER_TKN:
      case BIT_TKN:
      case OCTET_TKN:
      case NULL_TKN:
      case SEQUENCE_TKN:
      case SET_TKN:
      case CHOICE_TKN:
      case ANY_TKN:
      case COMPONENTS_TKN:
      case ENUMERATED_TKN:
      case EXTERNAL_TKN:
      case REAL_TKN:
      case LCASEFIRST_IDENT_TKN:
      case UCASEFIRST_IDENT_TKN:
        ElementTypeList();
        break;
      default:
        jj_la1[35] = jj_gen;
        ;
      }
      jj_consume_token(RIGHTBRACE_TKN);
                                                                 jjtree.closeNodeScope(jjtn000, true);
                                                                 jjtc000 = false;
                                                                 jjtreeCloseNodeScope(jjtn000);
                                                                 {if (true) return rc;}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
    throw new Error("Missing return statement in function");
  }

  static final public void ChoiceType() throws ParseException {
                     /*@bgen(jjtree) ChoiceType */
  ASTChoiceType jjtn000 = new ASTChoiceType(JJTCHOICETYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(CHOICE_TKN);
      jj_consume_token(LEFTBRACE_TKN);
      ElementTypeList();
      jj_consume_token(RIGHTBRACE_TKN);
    } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       {if (true) throw (RuntimeException)jjte000;}
     }
     if (jjte000 instanceof ParseException) {
       {if (true) throw (ParseException)jjte000;}
     }
     {if (true) throw (Error)jjte000;}
    } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
       jjtreeCloseNodeScope(jjtn000);
     }
    }
  }

  static final public void ElementTypeList() throws ParseException {
    ElementType();
    label_7:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA_TKN:
        ;
        break;
      default:
        jj_la1[36] = jj_gen;
        break label_7;
      }
      jj_consume_token(COMMA_TKN);
      ElementType();
    }
  }

  static final public void ElementType() throws ParseException {
                      /*@bgen(jjtree) ElementType */
  ASTElementType jjtn000 = new ASTElementType(JJTELEMENTTYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OBJECT_IDENTIFIER_TKN:
      case LEFTBRACKET_TKN:
      case BOOLEAN_TKN:
      case INTEGER_TKN:
      case BIT_TKN:
      case OCTET_TKN:
      case NULL_TKN:
      case SEQUENCE_TKN:
      case SET_TKN:
      case CHOICE_TKN:
      case ANY_TKN:
      case ENUMERATED_TKN:
      case EXTERNAL_TKN:
      case REAL_TKN:
      case LCASEFIRST_IDENT_TKN:
      case UCASEFIRST_IDENT_TKN:
        NamedType();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case OPTIONAL_TKN:
        case DEFAULT_TKN:
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case OPTIONAL_TKN:
            jj_consume_token(OPTIONAL_TKN);
                                      jjtn000.setOptional(true);
            break;
          case DEFAULT_TKN:
            jj_consume_token(DEFAULT_TKN);
            Value();
            break;
          default:
            jj_la1[37] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          break;
        default:
          jj_la1[38] = jj_gen;
          ;
        }
        break;
      case COMPONENTS_TKN:
        ComponentsType();
        break;
      default:
        jj_la1[39] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }

  static final public void ComponentsType() throws ParseException {
                         /*@bgen(jjtree) ComponentsType */
  ASTComponentsType jjtn000 = new ASTComponentsType(JJTCOMPONENTSTYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(COMPONENTS_TKN);
      jj_consume_token(OF_TKN);
      Type();
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }

  static final public void NamedType() throws ParseException {
    if (jj_2_6(2)) {
      identifier();
    } else {
      ;
    }
    Type();
  }

  static final public void SelectionType() throws ParseException {
                        /*@bgen(jjtree) SelectionType */
  ASTSelectionType jjtn000 = new ASTSelectionType(JJTSELECTIONTYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      identifier();
      jj_consume_token(LESSTHAN_TKN);
      Type();
    } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       {if (true) throw (RuntimeException)jjte000;}
     }
     if (jjte000 instanceof ParseException) {
       {if (true) throw (ParseException)jjte000;}
     }
     {if (true) throw (Error)jjte000;}
    } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
       jjtreeCloseNodeScope(jjtn000);
     }
    }
  }

  static final public void TaggedType() throws ParseException {
                     /*@bgen(jjtree) TaggedType */
  ASTTaggedType jjtn000 = new ASTTaggedType(JJTTAGGEDTYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      Tag();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IMPLICIT_TKN:
      case EXPLICIT_TKN:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case EXPLICIT_TKN:
          jj_consume_token(EXPLICIT_TKN);
                           jjtn000.setTaggingMethod(ASTTaggedType.EXPLICIT);
          break;
        case IMPLICIT_TKN:
          jj_consume_token(IMPLICIT_TKN);
                                                                                                  jjtn000.setTaggingMethod(ASTTaggedType.IMPLICIT);
          break;
        default:
          jj_la1[40] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_la1[41] = jj_gen;
        ;
      }
      Type();
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }

  static final public void Tag() throws ParseException {
              /*@bgen(jjtree) Tag */
  ASTTag jjtn000 = new ASTTag(JJTTAG);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(LEFTBRACKET_TKN);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case UNIVERSAL_TKN:
      case APPLICATION_TKN:
      case PRIVATE_TKN:
        Class();
        break;
      default:
        jj_la1[42] = jj_gen;
        ;
      }
      ClassNumber();
      jj_consume_token(RIGHTBRACKET_TKN);
    } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       {if (true) throw (RuntimeException)jjte000;}
     }
     if (jjte000 instanceof ParseException) {
       {if (true) throw (ParseException)jjte000;}
     }
     {if (true) throw (Error)jjte000;}
    } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
       jjtreeCloseNodeScope(jjtn000);
     }
    }
  }

  static final public void ClassNumber() throws ParseException {
                      /*@bgen(jjtree) ClassNumber */
                       ASTClassNumber jjtn000 = new ASTClassNumber(JJTCLASSNUMBER);
                       boolean jjtc000 = true;
                       jjtree.openNodeScope(jjtn000);
                       jjtreeOpenNodeScope(jjtn000);int x;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case NUMBER_ERANGE_TKN:
      case NUMBER_TKN:
        x = number();
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                  jjtreeCloseNodeScope(jjtn000);
                  jjtn000.setTagNumber(x);
        break;
      case LCASEFIRST_IDENT_TKN:
      case UCASEFIRST_IDENT_TKN:
        DefinedValue();
        break;
      default:
        jj_la1[43] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       {if (true) throw (RuntimeException)jjte000;}
     }
     if (jjte000 instanceof ParseException) {
       {if (true) throw (ParseException)jjte000;}
     }
     {if (true) throw (Error)jjte000;}
    } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
       jjtreeCloseNodeScope(jjtn000);
     }
    }
  }

  static final public void Class() throws ParseException {
                /*@bgen(jjtree) Class */
  ASTClass jjtn000 = new ASTClass(JJTCLASS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case UNIVERSAL_TKN:
        jj_consume_token(UNIVERSAL_TKN);
                       jjtree.closeNodeScope(jjtn000, true);
                       jjtc000 = false;
                       jjtreeCloseNodeScope(jjtn000);
                       jjtn000.setTagClass(ASTTaggedType.UNIVERSAL);
        break;
      case APPLICATION_TKN:
        jj_consume_token(APPLICATION_TKN);
                         jjtree.closeNodeScope(jjtn000, true);
                         jjtc000 = false;
                         jjtreeCloseNodeScope(jjtn000);
                         jjtn000.setTagClass(ASTTaggedType.APPLICATION);
        break;
      case PRIVATE_TKN:
        jj_consume_token(PRIVATE_TKN);
                     jjtree.closeNodeScope(jjtn000, true);
                     jjtc000 = false;
                     jjtreeCloseNodeScope(jjtn000);
                     jjtn000.setTagClass(ASTTaggedType.PRIVATE);
        break;
      default:
        jj_la1[44] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } finally {
       if (jjtc000) {
         jjtree.closeNodeScope(jjtn000, true);
         jjtreeCloseNodeScope(jjtn000);
       }
    }
  }

  static final public void AnyType() throws ParseException {
                  /*@bgen(jjtree) AnyType */
  ASTAnyType jjtn000 = new ASTAnyType(JJTANYTYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(ANY_TKN);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DEFINED_TKN:
        jj_consume_token(DEFINED_TKN);
        jj_consume_token(BY_TKN);
        identifier();
        break;
      default:
        jj_la1[45] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }

  static final public void SubtypeSpec() throws ParseException {
                      /*@bgen(jjtree) SubtypeSpec */
  ASTSubtypeSpec jjtn000 = new ASTSubtypeSpec(JJTSUBTYPESPEC);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(LEFTPAREN_TKN);
      SubtypeValueSetList();
      jj_consume_token(RIGHTPAREN_TKN);
    } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       {if (true) throw (RuntimeException)jjte000;}
     }
     if (jjte000 instanceof ParseException) {
       {if (true) throw (ParseException)jjte000;}
     }
     {if (true) throw (Error)jjte000;}
    } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
       jjtreeCloseNodeScope(jjtn000);
     }
    }
  }

  static final public void SubtypeValueSetList() throws ParseException {
                              /*@bgen(jjtree) SubtypeValueSetList */
  ASTSubtypeValueSetList jjtn000 = new ASTSubtypeValueSetList(JJTSUBTYPEVALUESETLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      SubtypeValueSet();
      label_8:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case BAR_TKN:
          ;
          break;
        default:
          jj_la1[46] = jj_gen;
          break label_8;
        }
        jj_consume_token(BAR_TKN);
        SubtypeValueSet();
      }
    } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       {if (true) throw (RuntimeException)jjte000;}
     }
     if (jjte000 instanceof ParseException) {
       {if (true) throw (ParseException)jjte000;}
     }
     {if (true) throw (Error)jjte000;}
    } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
       jjtreeCloseNodeScope(jjtn000);
     }
    }
  }

/**
 * TODO: implement CONTAINING token
 */
  static final public void SubtypeValueSet() throws ParseException {
                          /*@bgen(jjtree) SubtypeValueSet */
  ASTSubtypeValueSet jjtn000 = new ASTSubtypeValueSet(JJTSUBTYPEVALUESET);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BSTRING_TKN:
      case HSTRING_TKN:
      case CSTRING_TKN:
      case NUMBER_ERANGE_TKN:
      case NUMBER_TKN:
      case LEFTBRACE_TKN:
      case MINUS_TKN:
      case NULL_TKN:
      case TRUE_TKN:
      case FALSE_TKN:
      case MIN_TKN:
      case PLUS_INFINITY_TKN:
      case MINUS_INFINITY_TKN:
      case LCASEFIRST_IDENT_TKN:
      case UCASEFIRST_IDENT_TKN:
        ValueRange();
        break;
      case CONTAINING_TKN:
        jj_consume_token(CONTAINING_TKN);
        jj_consume_token(UCASEFIRST_IDENT_TKN);
        break;
      case INCLUDES_TKN:
        ContainedSubtype();
        break;
      case FROM_TKN:
        PermittedAlphabet();
        break;
      case SIZE_TKN:
        SizeConstraint();
        break;
      case WITH_TKN:
        InnerTypeConstraints();
        break;
      default:
        jj_la1[47] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       {if (true) throw (RuntimeException)jjte000;}
     }
     if (jjte000 instanceof ParseException) {
       {if (true) throw (ParseException)jjte000;}
     }
     {if (true) throw (Error)jjte000;}
    } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
       jjtreeCloseNodeScope(jjtn000);
     }
    }
  }

  static final public void ContainedSubtype() throws ParseException {
                           /*@bgen(jjtree) ContainedSubtype */
  ASTContainedSubtype jjtn000 = new ASTContainedSubtype(JJTCONTAINEDSUBTYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(INCLUDES_TKN);
      Type();
    } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       {if (true) throw (RuntimeException)jjte000;}
     }
     if (jjte000 instanceof ParseException) {
       {if (true) throw (ParseException)jjte000;}
     }
     {if (true) throw (Error)jjte000;}
    } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
       jjtreeCloseNodeScope(jjtn000);
     }
    }
  }

  static final public void SingleValue() throws ParseException {
                      /*@bgen(jjtree) SingleValue */
  ASTSingleValue jjtn000 = new ASTSingleValue(JJTSINGLEVALUE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      Value();
    } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       {if (true) throw (RuntimeException)jjte000;}
     }
     if (jjte000 instanceof ParseException) {
       {if (true) throw (ParseException)jjte000;}
     }
     {if (true) throw (Error)jjte000;}
    } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
       jjtreeCloseNodeScope(jjtn000);
     }
    }
  }

  static final public void ValueRange() throws ParseException {
                     /*@bgen(jjtree) ValueRange */
  ASTValueRange jjtn000 = new ASTValueRange(JJTVALUERANGE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BSTRING_TKN:
      case HSTRING_TKN:
      case CSTRING_TKN:
      case NUMBER_ERANGE_TKN:
      case NUMBER_TKN:
      case LEFTBRACE_TKN:
      case MINUS_TKN:
      case NULL_TKN:
      case TRUE_TKN:
      case FALSE_TKN:
      case PLUS_INFINITY_TKN:
      case MINUS_INFINITY_TKN:
      case LCASEFIRST_IDENT_TKN:
      case UCASEFIRST_IDENT_TKN:
        Value();
        break;
      case MIN_TKN:
        jj_consume_token(MIN_TKN);
        break;
      default:
        jj_la1[48] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DOT_TKN:
      case LESSTHAN_TKN:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LESSTHAN_TKN:
          jj_consume_token(LESSTHAN_TKN);
          break;
        default:
          jj_la1[49] = jj_gen;
          ;
        }
        jj_consume_token(DOT_TKN);
        jj_consume_token(DOT_TKN);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LESSTHAN_TKN:
          jj_consume_token(LESSTHAN_TKN);
          break;
        default:
          jj_la1[50] = jj_gen;
          ;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case BSTRING_TKN:
        case HSTRING_TKN:
        case CSTRING_TKN:
        case NUMBER_ERANGE_TKN:
        case NUMBER_TKN:
        case LEFTBRACE_TKN:
        case MINUS_TKN:
        case NULL_TKN:
        case TRUE_TKN:
        case FALSE_TKN:
        case PLUS_INFINITY_TKN:
        case MINUS_INFINITY_TKN:
        case LCASEFIRST_IDENT_TKN:
        case UCASEFIRST_IDENT_TKN:
          Value();
          break;
        case MAX_TKN:
          jj_consume_token(MAX_TKN);
          break;
        default:
          jj_la1[51] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_la1[52] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
   if (jjtc000) {
     jjtree.clearNodeScope(jjtn000);
     jjtc000 = false;
   } else {
     jjtree.popNode();
   }
   if (jjte000 instanceof RuntimeException) {
     {if (true) throw (RuntimeException)jjte000;}
   }
   if (jjte000 instanceof ParseException) {
     {if (true) throw (ParseException)jjte000;}
   }
   {if (true) throw (Error)jjte000;}
    } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
     jjtreeCloseNodeScope(jjtn000);
   }
    }
  }

  static final public void SizeConstraint() throws ParseException {
                         /*@bgen(jjtree) SizeConstraint */
  ASTSizeConstraint jjtn000 = new ASTSizeConstraint(JJTSIZECONSTRAINT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(SIZE_TKN);
      SubtypeSpec();
    } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       {if (true) throw (RuntimeException)jjte000;}
     }
     if (jjte000 instanceof ParseException) {
       {if (true) throw (ParseException)jjte000;}
     }
     {if (true) throw (Error)jjte000;}
    } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
       jjtreeCloseNodeScope(jjtn000);
     }
    }
  }

  static final public void PermittedAlphabet() throws ParseException {
                            /*@bgen(jjtree) PermittedAlphabet */
  ASTPermittedAlphabet jjtn000 = new ASTPermittedAlphabet(JJTPERMITTEDALPHABET);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(FROM_TKN);
      SubtypeSpec();
    } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       {if (true) throw (RuntimeException)jjte000;}
     }
     if (jjte000 instanceof ParseException) {
       {if (true) throw (ParseException)jjte000;}
     }
     {if (true) throw (Error)jjte000;}
    } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
       jjtreeCloseNodeScope(jjtn000);
     }
    }
  }

  static final public void InnerTypeConstraints() throws ParseException {
                               /*@bgen(jjtree) InnerTypeConstraints */
  ASTInnerTypeConstraints jjtn000 = new ASTInnerTypeConstraints(JJTINNERTYPECONSTRAINTS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(WITH_TKN);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMPONENT_TKN:
        jj_consume_token(COMPONENT_TKN);
        SingleTypeConstraint();
        break;
      case COMPONENTS_TKN:
        jj_consume_token(COMPONENTS_TKN);
        MultipleTypeConstraints();
        break;
      default:
        jj_la1[53] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }

  static final public void SingleTypeConstraint() throws ParseException {
                               /*@bgen(jjtree) SingleTypeConstraint */
  ASTSingleTypeConstraint jjtn000 = new ASTSingleTypeConstraint(JJTSINGLETYPECONSTRAINT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      SubtypeSpec();
    } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       {if (true) throw (RuntimeException)jjte000;}
     }
     if (jjte000 instanceof ParseException) {
       {if (true) throw (ParseException)jjte000;}
     }
     {if (true) throw (Error)jjte000;}
    } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
       jjtreeCloseNodeScope(jjtn000);
     }
    }
  }

  static final public void MultipleTypeConstraints() throws ParseException {
                                  /*@bgen(jjtree) MultipleTypeConstraints */
  ASTMultipleTypeConstraints jjtn000 = new ASTMultipleTypeConstraints(JJTMULTIPLETYPECONSTRAINTS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(LEFTBRACE_TKN);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DOT_TKN:
        jj_consume_token(DOT_TKN);
        jj_consume_token(DOT_TKN);
        jj_consume_token(DOT_TKN);
        jj_consume_token(COMMA_TKN);
        break;
      default:
        jj_la1[54] = jj_gen;
        ;
      }
      TypeConstraints();
      jj_consume_token(RIGHTBRACE_TKN);
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }

  static final public void TypeConstraints() throws ParseException {
                          /*@bgen(jjtree) TypeConstraints */
  ASTTypeConstraints jjtn000 = new ASTTypeConstraints(JJTTYPECONSTRAINTS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      NamedConstraint();
      label_9:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA_TKN:
          ;
          break;
        default:
          jj_la1[55] = jj_gen;
          break label_9;
        }
        jj_consume_token(COMMA_TKN);
        NamedConstraint();
      }
    } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       {if (true) throw (RuntimeException)jjte000;}
     }
     if (jjte000 instanceof ParseException) {
       {if (true) throw (ParseException)jjte000;}
     }
     {if (true) throw (Error)jjte000;}
    } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
       jjtreeCloseNodeScope(jjtn000);
     }
    }
  }

  static final public void NamedConstraint() throws ParseException {
                          /*@bgen(jjtree) NamedConstraint */
  ASTNamedConstraint jjtn000 = new ASTNamedConstraint(JJTNAMEDCONSTRAINT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LCASEFIRST_IDENT_TKN:
        identifier();
        break;
      default:
        jj_la1[56] = jj_gen;
        ;
      }
      Constraint();
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
  }

  static final public void Constraint() throws ParseException {
                     /*@bgen(jjtree) Constraint */
  ASTConstraint jjtn000 = new ASTConstraint(JJTCONSTRAINT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LEFTPAREN_TKN:
        ValueConstraint();
        break;
      default:
        jj_la1[57] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OPTIONAL_TKN:
      case PRESENT_TKN:
      case ABSENT_TKN:
        PresenceConstraint();
        break;
      default:
        jj_la1[58] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }

  static final public void ValueConstraint() throws ParseException {
                          /*@bgen(jjtree) ValueConstraint */
  ASTValueConstraint jjtn000 = new ASTValueConstraint(JJTVALUECONSTRAINT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      SubtypeSpec();
    } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       {if (true) throw (RuntimeException)jjte000;}
     }
     if (jjte000 instanceof ParseException) {
       {if (true) throw (ParseException)jjte000;}
     }
     {if (true) throw (Error)jjte000;}
    } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
       jjtreeCloseNodeScope(jjtn000);
     }
    }
  }

  static final public void PresenceConstraint() throws ParseException {
                             /*@bgen(jjtree) PresenceConstraint */
  ASTPresenceConstraint jjtn000 = new ASTPresenceConstraint(JJTPRESENCECONSTRAINT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PRESENT_TKN:
        jj_consume_token(PRESENT_TKN);
        break;
      case ABSENT_TKN:
        jj_consume_token(ABSENT_TKN);
        break;
      case OPTIONAL_TKN:
        jj_consume_token(OPTIONAL_TKN);
        break;
      default:
        jj_la1[59] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
       jjtreeCloseNodeScope(jjtn000);
     }
    }
  }

  static final public void ValueAssignment() throws ParseException {
                          /*@bgen(jjtree) ValueAssignment */
  ASTValueAssignment jjtn000 = new ASTValueAssignment(JJTVALUEASSIGNMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      identifier();
      GlobalType();
      jj_consume_token(GETS_TKN);
      if (jj_2_7(2)) {
        identifier();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SELECTOR_TKN:
          jj_consume_token(SELECTOR_TKN);
          break;
        default:
          jj_la1[60] = jj_gen;
          ;
        }
      } else {
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BSTRING_TKN:
      case HSTRING_TKN:
      case CSTRING_TKN:
      case NUMBER_ERANGE_TKN:
      case NUMBER_TKN:
      case LEFTBRACE_TKN:
      case MINUS_TKN:
      case NULL_TKN:
      case TRUE_TKN:
      case FALSE_TKN:
      case PLUS_INFINITY_TKN:
      case MINUS_INFINITY_TKN:
        BuiltinValue();
        break;
      default:
        jj_la1[61] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
  }

  static final public void Value() throws ParseException {
                /*@bgen(jjtree) Value */
  ASTValue jjtn000 = new ASTValue(JJTVALUE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      if (jj_2_8(2)) {
        BuiltinValue();
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LCASEFIRST_IDENT_TKN:
        case UCASEFIRST_IDENT_TKN:
          DefinedValue();
          break;
        default:
          jj_la1[62] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       {if (true) throw (RuntimeException)jjte000;}
     }
     if (jjte000 instanceof ParseException) {
       {if (true) throw (ParseException)jjte000;}
     }
     {if (true) throw (Error)jjte000;}
    } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
       jjtreeCloseNodeScope(jjtn000);
     }
    }
  }

  static final public void DefinedValue() throws ParseException {
                       /*@bgen(jjtree) DefinedValue */
  ASTDefinedValue jjtn000 = new ASTDefinedValue(JJTDEFINEDVALUE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case UCASEFIRST_IDENT_TKN:
        modulereference();
        jj_consume_token(DOT_TKN);
        break;
      default:
        jj_la1[63] = jj_gen;
        ;
      }
      identifier();
    } catch (Throwable jjte000) {
   if (jjtc000) {
     jjtree.clearNodeScope(jjtn000);
     jjtc000 = false;
   } else {
     jjtree.popNode();
   }
   if (jjte000 instanceof RuntimeException) {
     {if (true) throw (RuntimeException)jjte000;}
   }
   if (jjte000 instanceof ParseException) {
     {if (true) throw (ParseException)jjte000;}
   }
   {if (true) throw (Error)jjte000;}
    } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
     jjtreeCloseNodeScope(jjtn000);
   }
    }
  }

  static final public void BuiltinValue() throws ParseException {
                       /*@bgen(jjtree) BuiltinValue */
  ASTBuiltinValue jjtn000 = new ASTBuiltinValue(JJTBUILTINVALUE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TRUE_TKN:
      case FALSE_TKN:
        BooleanValue();
        break;
      case NULL_TKN:
        NullValue();
        break;
      case PLUS_INFINITY_TKN:
      case MINUS_INFINITY_TKN:
        SpecialRealValue();
        break;
      case NUMBER_ERANGE_TKN:
      case NUMBER_TKN:
      case MINUS_TKN:
        SignedNumber();
        break;
      case HSTRING_TKN:
        HexString();
        break;
      case BSTRING_TKN:
        BinaryString();
        break;
      case CSTRING_TKN:
        CharString();
        break;
      case LEFTBRACE_TKN:
        CompoundValue();
        break;
      default:
        jj_la1[64] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       {if (true) throw (RuntimeException)jjte000;}
     }
     if (jjte000 instanceof ParseException) {
       {if (true) throw (ParseException)jjte000;}
     }
     {if (true) throw (Error)jjte000;}
    } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
       jjtreeCloseNodeScope(jjtn000);
     }
    }
  }

  static final public void CompoundValue() throws ParseException {
                        /*@bgen(jjtree) CompoundValue */
  ASTCompoundValue jjtn000 = new ASTCompoundValue(JJTCOMPOUNDVALUE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(LEFTBRACE_TKN);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case NUMBER_ERANGE_TKN:
      case NUMBER_TKN:
      case LCASEFIRST_IDENT_TKN:
        ObjIdComponentList();
        break;
      default:
        jj_la1[65] = jj_gen;
        skip_to_matching_brace();
      }
      jj_consume_token(RIGHTBRACE_TKN);
    } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       {if (true) throw (RuntimeException)jjte000;}
     }
     if (jjte000 instanceof ParseException) {
       {if (true) throw (ParseException)jjte000;}
     }
     {if (true) throw (Error)jjte000;}
    } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
       jjtreeCloseNodeScope(jjtn000);
     }
    }
  }

  static void skip_to_matching_brace() throws ParseException {
                               /*@bgen(jjtree) skip_to_matching_brace */
ASTskip_to_matching_brace jjtn000 = new ASTskip_to_matching_brace(JJTSKIP_TO_MATCHING_BRACE);
boolean jjtc000 = true;
jjtree.openNodeScope(jjtn000);
jjtreeOpenNodeScope(jjtn000);
try {Token tok;
  int nesting = 1;
  while (true) {
    tok = getToken(1);
    if (tok.kind == LEFTBRACE_TKN) nesting++;
    if (tok.kind == RIGHTBRACE_TKN) {
      nesting--;
         if (nesting == 0) break;
    }
    tok = getNextToken();
  }/*@bgen(jjtree)*/
} finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
    jjtreeCloseNodeScope(jjtn000);
  }
}
  }

  static final public void BooleanValue() throws ParseException {
                       /*@bgen(jjtree) BooleanValue */
  ASTBooleanValue jjtn000 = new ASTBooleanValue(JJTBOOLEANVALUE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TRUE_TKN:
        jj_consume_token(TRUE_TKN);
        break;
      case FALSE_TKN:
        jj_consume_token(FALSE_TKN);
        break;
      default:
        jj_la1[66] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
       jjtreeCloseNodeScope(jjtn000);
     }
    }
  }

  static final public void SpecialRealValue() throws ParseException {
                           /*@bgen(jjtree) SpecialRealValue */
  ASTSpecialRealValue jjtn000 = new ASTSpecialRealValue(JJTSPECIALREALVALUE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PLUS_INFINITY_TKN:
        jj_consume_token(PLUS_INFINITY_TKN);
        break;
      case MINUS_INFINITY_TKN:
        jj_consume_token(MINUS_INFINITY_TKN);
        break;
      default:
        jj_la1[67] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
       jjtreeCloseNodeScope(jjtn000);
     }
    }
  }

  static final public void NullValue() throws ParseException {
                    /*@bgen(jjtree) NullValue */
  ASTNullValue jjtn000 = new ASTNullValue(JJTNULLVALUE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(NULL_TKN);
    } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
       jjtreeCloseNodeScope(jjtn000);
     }
    }
  }

  static final public void NamedValue() throws ParseException {
                     /*@bgen(jjtree) NamedValue */
  ASTNamedValue jjtn000 = new ASTNamedValue(JJTNAMEDVALUE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      if (jj_2_9(2)) {
        identifier();
      } else {
        ;
      }
      Value();
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }

  static final public void ObjectIdentifierValue() throws ParseException {
                                /*@bgen(jjtree) ObjectIdentifierValue */
  ASTObjectIdentifierValue jjtn000 = new ASTObjectIdentifierValue(JJTOBJECTIDENTIFIERVALUE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(LEFTBRACE_TKN);
      ObjIdComponentList();
      jj_consume_token(RIGHTBRACE_TKN);
    } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       {if (true) throw (RuntimeException)jjte000;}
     }
     if (jjte000 instanceof ParseException) {
       {if (true) throw (ParseException)jjte000;}
     }
     {if (true) throw (Error)jjte000;}
    } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
       jjtreeCloseNodeScope(jjtn000);
     }
    }
  }

  static final public void ObjIdComponentList() throws ParseException {
                             /*@bgen(jjtree) ObjIdComponentList */
  ASTObjIdComponentList jjtn000 = new ASTObjIdComponentList(JJTOBJIDCOMPONENTLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      ObjIdComponent();
      label_10:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case NUMBER_ERANGE_TKN:
        case NUMBER_TKN:
        case LCASEFIRST_IDENT_TKN:
          ;
          break;
        default:
          jj_la1[68] = jj_gen;
          break label_10;
        }
        ObjIdComponent();
      }
    } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       {if (true) throw (RuntimeException)jjte000;}
     }
     if (jjte000 instanceof ParseException) {
       {if (true) throw (ParseException)jjte000;}
     }
     {if (true) throw (Error)jjte000;}
    } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
       jjtreeCloseNodeScope(jjtn000);
     }
    }
  }

  static final public void ObjIdComponent() throws ParseException {
                         /*@bgen(jjtree) ObjIdComponent */
  ASTObjIdComponent jjtn000 = new ASTObjIdComponent(JJTOBJIDCOMPONENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case NUMBER_ERANGE_TKN:
      case NUMBER_TKN:
        NumberForm();
        break;
      case LCASEFIRST_IDENT_TKN:
        NameAndNumberForm();
        break;
      default:
        jj_la1[69] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }

  static final public void NumberForm() throws ParseException {
                     /*@bgen(jjtree) NumberForm */
  ASTNumberForm jjtn000 = new ASTNumberForm(JJTNUMBERFORM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      number();
    } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       {if (true) throw (RuntimeException)jjte000;}
     }
     if (jjte000 instanceof ParseException) {
       {if (true) throw (ParseException)jjte000;}
     }
     {if (true) throw (Error)jjte000;}
    } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
       jjtreeCloseNodeScope(jjtn000);
     }
    }
  }

  static final public void NameAndNumberForm() throws ParseException {
                            /*@bgen(jjtree) NameAndNumberForm */
  ASTNameAndNumberForm jjtn000 = new ASTNameAndNumberForm(JJTNAMEANDNUMBERFORM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      identifier();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LEFTPAREN_TKN:
        jj_consume_token(LEFTPAREN_TKN);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case NUMBER_ERANGE_TKN:
        case NUMBER_TKN:
          NumberForm();
          break;
        case LCASEFIRST_IDENT_TKN:
        case UCASEFIRST_IDENT_TKN:
          DefinedValue();
          break;
        default:
          jj_la1[70] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        jj_consume_token(RIGHTPAREN_TKN);
        break;
      default:
        jj_la1[71] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }

  static final public void BinaryString() throws ParseException {
                       /*@bgen(jjtree) BinaryString */
  ASTBinaryString jjtn000 = new ASTBinaryString(JJTBINARYSTRING);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(BSTRING_TKN);
    } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
       jjtreeCloseNodeScope(jjtn000);
     }
    }
  }

  static final public void HexString() throws ParseException {
                    /*@bgen(jjtree) HexString */
  ASTHexString jjtn000 = new ASTHexString(JJTHEXSTRING);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(HSTRING_TKN);
    } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
       jjtreeCloseNodeScope(jjtn000);
     }
    }
  }

  static final public void CharString() throws ParseException {
                     /*@bgen(jjtree) CharString */
  ASTCharString jjtn000 = new ASTCharString(JJTCHARSTRING);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(CSTRING_TKN);
    } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
       jjtreeCloseNodeScope(jjtn000);
     }
    }
  }

  static final public int number() throws ParseException {
                /*@bgen(jjtree) number */
  ASTnumber jjtn000 = new ASTnumber(JJTNUMBER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case NUMBER_TKN:
        jj_consume_token(NUMBER_TKN);
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                  jjtreeCloseNodeScope(jjtn000);
                  {if (true) return 0;}
        break;
      case NUMBER_ERANGE_TKN:
        jj_consume_token(NUMBER_ERANGE_TKN);
                                                      jjtree.closeNodeScope(jjtn000, true);
                                                      jjtc000 = false;
                                                      jjtreeCloseNodeScope(jjtn000);
                                                      {if (true) return Integer.parseInt(token.image);}
        break;
      default:
        jj_la1[72] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
       jjtreeCloseNodeScope(jjtn000);
     }
    }
    throw new Error("Missing return statement in function");
  }

  static final public void identifier() throws ParseException {
                     /*@bgen(jjtree) identifier */
  ASTidentifier jjtn000 = new ASTidentifier(JJTIDENTIFIER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(LCASEFIRST_IDENT_TKN);
    } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
       jjtreeCloseNodeScope(jjtn000);
     }
    }
  }

  static final public void modulereference() throws ParseException {
                          /*@bgen(jjtree) modulereference */
  ASTmodulereference jjtn000 = new ASTmodulereference(JJTMODULEREFERENCE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(UCASEFIRST_IDENT_TKN);
    } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
       jjtreeCloseNodeScope(jjtn000);
     }
    }
  }

  static final public void typereference() throws ParseException {
                        /*@bgen(jjtree) typereference */
  ASTtypereference jjtn000 = new ASTtypereference(JJTTYPEREFERENCE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(UCASEFIRST_IDENT_TKN);
    } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
       jjtreeCloseNodeScope(jjtn000);
     }
    }
  }

  static final public void DefinedMacroType() throws ParseException {
                           /*@bgen(jjtree) DefinedMacroType */
  ASTDefinedMacroType jjtn000 = new ASTDefinedMacroType(JJTDEFINEDMACROTYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TC_TKN:
        TextualConventionMacroType();
        break;
      case OBJECTTYPE_TKN:
        SnmpObjectTypeMacroType();
        break;
      default:
        jj_la1[73] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }

  static final public void DefinedMacroName() throws ParseException {
                           /*@bgen(jjtree) DefinedMacroName */
  ASTDefinedMacroName jjtn000 = new ASTDefinedMacroName(JJTDEFINEDMACRONAME);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OBJECTTYPE_TKN:
        jj_consume_token(OBJECTTYPE_TKN);
        break;
      case TC_TKN:
        jj_consume_token(TC_TKN);
        break;
      default:
        jj_la1[74] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }

  static final public void SnmpObjectTypeMacroType() throws ParseException {
                                  /*@bgen(jjtree) SnmpObjectTypeMacroType */
  ASTSnmpObjectTypeMacroType jjtn000 = new ASTSnmpObjectTypeMacroType(JJTSNMPOBJECTTYPEMACROTYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(OBJECTTYPE_TKN);
      jj_consume_token(SYNTAX_TKN);
      Type();
      jj_consume_token(ACCESS_TKN);
      SnmpAccess();
      jj_consume_token(STATUS_TKN);
      SnmpStatus();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DESCRIPTION_TKN:
        SnmpDescrPart();
        break;
      default:
        jj_la1[75] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case REFERENCE_TKN:
        SnmpReferPart();
        break;
      default:
        jj_la1[76] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INDEX_TKN:
        SnmpIndexPart();
        break;
      default:
        jj_la1[77] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DEFVAL_TKN:
        SnmpDefValPart();
        break;
      default:
        jj_la1[78] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       {if (true) throw (RuntimeException)jjte000;}
     }
     if (jjte000 instanceof ParseException) {
       {if (true) throw (ParseException)jjte000;}
     }
     {if (true) throw (Error)jjte000;}
    } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
       jjtreeCloseNodeScope(jjtn000);
     }
    }
  }

  static final public void SnmpAccess() throws ParseException {
                     /*@bgen(jjtree) SnmpAccess */
  ASTSnmpAccess jjtn000 = new ASTSnmpAccess(JJTSNMPACCESS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      identifier();
    } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       {if (true) throw (RuntimeException)jjte000;}
     }
     if (jjte000 instanceof ParseException) {
       {if (true) throw (ParseException)jjte000;}
     }
     {if (true) throw (Error)jjte000;}
    } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
       jjtreeCloseNodeScope(jjtn000);
     }
    }
  }

  static final public void SnmpStatus() throws ParseException {
                     /*@bgen(jjtree) SnmpStatus */
  ASTSnmpStatus jjtn000 = new ASTSnmpStatus(JJTSNMPSTATUS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      identifier();
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }

  static final public void SnmpDescrPart() throws ParseException {
                        /*@bgen(jjtree) SnmpDescrPart */
  ASTSnmpDescrPart jjtn000 = new ASTSnmpDescrPart(JJTSNMPDESCRPART);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(DESCRIPTION_TKN);
      jj_consume_token(CSTRING_TKN);
    } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
       jjtreeCloseNodeScope(jjtn000);
     }
    }
  }

  static final public void SnmpReferPart() throws ParseException {
                        /*@bgen(jjtree) SnmpReferPart */
  ASTSnmpReferPart jjtn000 = new ASTSnmpReferPart(JJTSNMPREFERPART);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(REFERENCE_TKN);
      jj_consume_token(CSTRING_TKN);
    } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
       jjtreeCloseNodeScope(jjtn000);
     }
    }
  }

  static final public void SnmpIndexPart() throws ParseException {
                        /*@bgen(jjtree) SnmpIndexPart */
  ASTSnmpIndexPart jjtn000 = new ASTSnmpIndexPart(JJTSNMPINDEXPART);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(INDEX_TKN);
      jj_consume_token(LEFTBRACE_TKN);
      TypeOrValueList();
      jj_consume_token(RIGHTBRACE_TKN);
    } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       {if (true) throw (RuntimeException)jjte000;}
     }
     if (jjte000 instanceof ParseException) {
       {if (true) throw (ParseException)jjte000;}
     }
     {if (true) throw (Error)jjte000;}
    } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
       jjtreeCloseNodeScope(jjtn000);
     }
    }
  }

  static final public void TypeOrValueList() throws ParseException {
                          /*@bgen(jjtree) TypeOrValueList */
  ASTTypeOrValueList jjtn000 = new ASTTypeOrValueList(JJTTYPEORVALUELIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      TypeOrValue();
      label_11:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA_TKN:
          ;
          break;
        default:
          jj_la1[79] = jj_gen;
          break label_11;
        }
        jj_consume_token(COMMA_TKN);
        TypeOrValue();
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }

  static final public void TypeOrValue() throws ParseException {
                      /*@bgen(jjtree) TypeOrValue */
  ASTTypeOrValue jjtn000 = new ASTTypeOrValue(JJTTYPEORVALUE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      if (jj_2_10(3)) {
        Type();
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case BSTRING_TKN:
        case HSTRING_TKN:
        case CSTRING_TKN:
        case NUMBER_ERANGE_TKN:
        case NUMBER_TKN:
        case LEFTBRACE_TKN:
        case MINUS_TKN:
        case NULL_TKN:
        case TRUE_TKN:
        case FALSE_TKN:
        case PLUS_INFINITY_TKN:
        case MINUS_INFINITY_TKN:
        case LCASEFIRST_IDENT_TKN:
        case UCASEFIRST_IDENT_TKN:
          Value();
          break;
        default:
          jj_la1[80] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }

  static final public void SnmpDefValPart() throws ParseException {
                         /*@bgen(jjtree) SnmpDefValPart */
  ASTSnmpDefValPart jjtn000 = new ASTSnmpDefValPart(JJTSNMPDEFVALPART);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(DEFVAL_TKN);
      jj_consume_token(LEFTBRACE_TKN);
      Value();
      jj_consume_token(RIGHTBRACE_TKN);
    } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       {if (true) throw (RuntimeException)jjte000;}
     }
     if (jjte000 instanceof ParseException) {
       {if (true) throw (ParseException)jjte000;}
     }
     {if (true) throw (Error)jjte000;}
    } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
       jjtreeCloseNodeScope(jjtn000);
     }
    }
  }

  static final public void TextualConventionMacroType() throws ParseException {
                                     /*@bgen(jjtree) TextualConventionMacroType */
  ASTTextualConventionMacroType jjtn000 = new ASTTextualConventionMacroType(JJTTEXTUALCONVENTIONMACROTYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(TC_TKN);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DHINT:
        DisplayHint();
        break;
      default:
        jj_la1[81] = jj_gen;
        ;
      }
      jj_consume_token(STATUS_TKN);
      SnmpStatus();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DESCRIPTION_TKN:
        SnmpDescrPart();
        break;
      default:
        jj_la1[82] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case REFERENCE_TKN:
        SnmpReferPart();
        break;
      default:
        jj_la1[83] = jj_gen;
        ;
      }
      jj_consume_token(SYNTAX_TKN);
      Type();
    } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       {if (true) throw (RuntimeException)jjte000;}
     }
     if (jjte000 instanceof ParseException) {
       {if (true) throw (ParseException)jjte000;}
     }
     {if (true) throw (Error)jjte000;}
    } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
       jjtreeCloseNodeScope(jjtn000);
     }
    }
  }

  static final public void DisplayHint() throws ParseException {
                      /*@bgen(jjtree) DisplayHint */
  ASTDisplayHint jjtn000 = new ASTDisplayHint(JJTDISPLAYHINT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(DHINT);
      jj_consume_token(CSTRING_TKN);
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }

  static private boolean jj_2_1(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_1(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(0, xla); }
  }

  static private boolean jj_2_2(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_2(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(1, xla); }
  }

  static private boolean jj_2_3(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_3(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(2, xla); }
  }

  static private boolean jj_2_4(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_4(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(3, xla); }
  }

  static private boolean jj_2_5(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_5(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(4, xla); }
  }

  static private boolean jj_2_6(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_6(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(5, xla); }
  }

  static private boolean jj_2_7(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_7(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(6, xla); }
  }

  static private boolean jj_2_8(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_8(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(7, xla); }
  }

  static private boolean jj_2_9(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_9(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(8, xla); }
  }

  static private boolean jj_2_10(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_10(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(9, xla); }
  }

  static private boolean jj_3R_59() {
    if (jj_scan_token(NULL_TKN)) return true;
    return false;
  }

  static private boolean jj_3R_34() {
    if (jj_scan_token(EXTERNAL_TKN)) return true;
    return false;
  }

  static private boolean jj_3R_33() {
    if (jj_3R_59()) return true;
    return false;
  }

  static private boolean jj_3R_90() {
    if (jj_scan_token(WITH_TKN)) return true;
    return false;
  }

  static private boolean jj_3R_32() {
    if (jj_3R_58()) return true;
    return false;
  }

  static private boolean jj_3R_31() {
    if (jj_scan_token(REAL_TKN)) return true;
    return false;
  }

  static private boolean jj_3R_30() {
    if (jj_3R_57()) return true;
    return false;
  }

  static private boolean jj_3R_29() {
    if (jj_3R_56()) return true;
    return false;
  }

  static private boolean jj_3R_89() {
    if (jj_scan_token(FROM_TKN)) return true;
    return false;
  }

  static private boolean jj_3R_28() {
    if (jj_3R_55()) return true;
    return false;
  }

  static private boolean jj_3R_27() {
    if (jj_3R_54()) return true;
    return false;
  }

  static private boolean jj_3R_81() {
    if (jj_3R_90()) return true;
    return false;
  }

  static private boolean jj_3R_26() {
    if (jj_3R_53()) return true;
    return false;
  }

  static private boolean jj_3R_25() {
    if (jj_3R_52()) return true;
    return false;
  }

  static private boolean jj_3R_24() {
    if (jj_3R_51()) return true;
    return false;
  }

  static private boolean jj_3R_112() {
    if (jj_scan_token(NUMBER_ERANGE_TKN)) return true;
    return false;
  }

  static private boolean jj_3R_84() {
    if (jj_scan_token(SIZE_TKN)) return true;
    if (jj_3R_14()) return true;
    return false;
  }

  static private boolean jj_3R_23() {
    if (jj_3R_50()) return true;
    return false;
  }

  static private boolean jj_3_5() {
    if (jj_3R_16()) return true;
    return false;
  }

  static private boolean jj_3R_22() {
    if (jj_3R_49()) return true;
    return false;
  }

  static private boolean jj_3R_21() {
    if (jj_3R_48()) return true;
    return false;
  }

  static private boolean jj_3R_13() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_21()) {
    jj_scanpos = xsp;
    if (jj_3R_22()) {
    jj_scanpos = xsp;
    if (jj_3_5()) {
    jj_scanpos = xsp;
    if (jj_3R_23()) {
    jj_scanpos = xsp;
    if (jj_3R_24()) {
    jj_scanpos = xsp;
    if (jj_3R_25()) {
    jj_scanpos = xsp;
    if (jj_3R_26()) {
    jj_scanpos = xsp;
    if (jj_3R_27()) {
    jj_scanpos = xsp;
    if (jj_3R_28()) {
    jj_scanpos = xsp;
    if (jj_3R_29()) {
    jj_scanpos = xsp;
    if (jj_3R_30()) {
    jj_scanpos = xsp;
    if (jj_3R_31()) {
    jj_scanpos = xsp;
    if (jj_3R_32()) {
    jj_scanpos = xsp;
    if (jj_3R_33()) {
    jj_scanpos = xsp;
    if (jj_3R_34()) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  static private boolean jj_3R_77() {
    if (jj_scan_token(CONTAINING_TKN)) return true;
    return false;
  }

  static private boolean jj_3R_95() {
    if (jj_3R_106()) return true;
    return false;
  }

  static private boolean jj_3R_87() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_95()) {
    jj_scanpos = xsp;
    if (jj_scan_token(61)) return true;
    }
    return false;
  }

  static private boolean jj_3_4() {
    if (jj_3R_15()) return true;
    if (jj_scan_token(DOT_TKN)) return true;
    return false;
  }

  static private boolean jj_3R_69() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_4()) jj_scanpos = xsp;
    if (jj_3R_47()) return true;
    return false;
  }

  static private boolean jj_3R_94() {
    if (jj_3R_105()) return true;
    return false;
  }

  static private boolean jj_3_3() {
    if (jj_3R_14()) return true;
    return false;
  }

  static private boolean jj_3R_46() {
    if (jj_3R_69()) return true;
    return false;
  }

  static private boolean jj_3R_47() {
    if (jj_scan_token(UCASEFIRST_IDENT_TKN)) return true;
    return false;
  }

  static private boolean jj_3R_88() {
    if (jj_scan_token(INCLUDES_TKN)) return true;
    return false;
  }

  static private boolean jj_3R_80() {
    if (jj_3R_84()) return true;
    return false;
  }

  static private boolean jj_3R_76() {
    if (jj_3R_87()) return true;
    return false;
  }

  static private boolean jj_3R_15() {
    if (jj_scan_token(UCASEFIRST_IDENT_TKN)) return true;
    return false;
  }

  static private boolean jj_3_2() {
    if (jj_3R_13()) return true;
    return false;
  }

  static private boolean jj_3R_19() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_2()) {
    jj_scanpos = xsp;
    if (jj_3R_46()) return true;
    }
    xsp = jj_scanpos;
    if (jj_3_3()) jj_scanpos = xsp;
    return false;
  }

  static private boolean jj_3R_60() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_76()) {
    jj_scanpos = xsp;
    if (jj_3R_77()) {
    jj_scanpos = xsp;
    if (jj_3R_78()) {
    jj_scanpos = xsp;
    if (jj_3R_79()) {
    jj_scanpos = xsp;
    if (jj_3R_80()) {
    jj_scanpos = xsp;
    if (jj_3R_81()) return true;
    }
    }
    }
    }
    }
    return false;
  }

  static private boolean jj_3R_17() {
    if (jj_scan_token(LCASEFIRST_IDENT_TKN)) return true;
    return false;
  }

  static private boolean jj_3R_111() {
    if (jj_scan_token(NUMBER_TKN)) return true;
    return false;
  }

  static private boolean jj_3R_104() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_111()) {
    jj_scanpos = xsp;
    if (jj_3R_112()) return true;
    }
    return false;
  }

  static private boolean jj_3R_35() {
    if (jj_3R_60()) return true;
    return false;
  }

  static private boolean jj_3R_67() {
    if (jj_scan_token(CSTRING_TKN)) return true;
    return false;
  }

  static private boolean jj_3R_14() {
    if (jj_scan_token(LEFTPAREN_TKN)) return true;
    if (jj_3R_35()) return true;
    return false;
  }

  static private boolean jj_3R_65() {
    if (jj_scan_token(HSTRING_TKN)) return true;
    return false;
  }

  static private boolean jj_3R_85() {
    if (jj_3R_92()) return true;
    return false;
  }

  static private boolean jj_3R_75() {
    if (jj_scan_token(DEFINED_TKN)) return true;
    if (jj_scan_token(BY_TKN)) return true;
    return false;
  }

  static private boolean jj_3R_20() {
    if (jj_3R_47()) return true;
    return false;
  }

  static private boolean jj_3R_108() {
    if (jj_3R_116()) return true;
    return false;
  }

  static private boolean jj_3R_54() {
    if (jj_scan_token(ANY_TKN)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_75()) jj_scanpos = xsp;
    return false;
  }

  static private boolean jj_3R_66() {
    if (jj_scan_token(BSTRING_TKN)) return true;
    return false;
  }

  static private boolean jj_3R_103() {
    if (jj_scan_token(PRIVATE_TKN)) return true;
    return false;
  }

  static private boolean jj_3R_102() {
    if (jj_scan_token(APPLICATION_TKN)) return true;
    return false;
  }

  static private boolean jj_3R_101() {
    if (jj_scan_token(UNIVERSAL_TKN)) return true;
    return false;
  }

  static private boolean jj_3R_92() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_101()) {
    jj_scanpos = xsp;
    if (jj_3R_102()) {
    jj_scanpos = xsp;
    if (jj_3R_103()) return true;
    }
    }
    return false;
  }

  static private boolean jj_3R_116() {
    if (jj_3R_17()) return true;
    return false;
  }

  static private boolean jj_3R_93() {
    if (jj_3R_104()) return true;
    return false;
  }

  static private boolean jj_3R_86() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_93()) {
    jj_scanpos = xsp;
    if (jj_3R_94()) return true;
    }
    return false;
  }

  static private boolean jj_3R_115() {
    if (jj_3R_104()) return true;
    return false;
  }

  static private boolean jj_3R_107() {
    if (jj_3R_115()) return true;
    return false;
  }

  static private boolean jj_3R_74() {
    if (jj_scan_token(LEFTBRACKET_TKN)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_85()) jj_scanpos = xsp;
    if (jj_3R_86()) return true;
    if (jj_scan_token(RIGHTBRACKET_TKN)) return true;
    return false;
  }

  static private boolean jj_3R_96() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_107()) {
    jj_scanpos = xsp;
    if (jj_3R_108()) return true;
    }
    return false;
  }

  static private boolean jj_3R_91() {
    if (jj_3R_96()) return true;
    return false;
  }

  static private boolean jj_3R_53() {
    if (jj_3R_74()) return true;
    return false;
  }

  static private boolean jj_3R_83() {
    if (true) { jj_la = 0; jj_scanpos = jj_lastpos; return false;}
    return false;
  }

  static private boolean jj_3R_52() {
    if (jj_3R_17()) return true;
    if (jj_scan_token(LESSTHAN_TKN)) return true;
    if (jj_3R_19()) return true;
    return false;
  }

  static private boolean jj_3R_12() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(82)) {
    jj_scanpos = xsp;
    if (jj_scan_token(73)) {
    jj_scanpos = xsp;
    if (jj_3R_20()) return true;
    }
    }
    if (jj_scan_token(MACRO_TKN)) return true;
    return false;
  }

  static private boolean jj_3_6() {
    if (jj_3R_17()) return true;
    return false;
  }

  static private boolean jj_3_9() {
    if (jj_3R_17()) return true;
    return false;
  }

  static private boolean jj_3R_119() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_6()) jj_scanpos = xsp;
    if (jj_3R_19()) return true;
    return false;
  }

  static private boolean jj_3_1() {
    if (jj_3R_12()) return true;
    return false;
  }

  static private boolean jj_3R_73() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(18)) jj_scanpos = xsp;
    if (jj_3R_84()) return true;
    return false;
  }

  static private boolean jj_3R_62() {
    if (jj_scan_token(NULL_TKN)) return true;
    return false;
  }

  static private boolean jj_3R_120() {
    if (jj_scan_token(COMPONENTS_TKN)) return true;
    return false;
  }

  static private boolean jj_3R_98() {
    if (jj_3R_99()) return true;
    return false;
  }

  static private boolean jj_3R_63() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(71)) {
    jj_scanpos = xsp;
    if (jj_scan_token(72)) return true;
    }
    return false;
  }

  static private boolean jj_3R_118() {
    if (jj_3R_120()) return true;
    return false;
  }

  static private boolean jj_3R_117() {
    if (jj_3R_119()) return true;
    return false;
  }

  static private boolean jj_3R_109() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_117()) {
    jj_scanpos = xsp;
    if (jj_3R_118()) return true;
    }
    return false;
  }

  static private boolean jj_3R_61() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(47)) {
    jj_scanpos = xsp;
    if (jj_scan_token(48)) return true;
    }
    return false;
  }

  static private boolean jj_3R_99() {
    if (jj_3R_109()) return true;
    return false;
  }

  static private boolean jj_3R_82() {
    if (jj_3R_91()) return true;
    return false;
  }

  static private boolean jj_3R_51() {
    if (jj_scan_token(CHOICE_TKN)) return true;
    if (jj_scan_token(LEFTBRACE_TKN)) return true;
    if (jj_3R_99()) return true;
    return false;
  }

  static private boolean jj_3R_37() {
    if (jj_scan_token(SEQUENCE_TKN)) return true;
    return false;
  }

  static private boolean jj_3R_36() {
    if (jj_scan_token(SET_TKN)) return true;
    return false;
  }

  static private boolean jj_3R_114() {
    if (jj_3R_105()) return true;
    return false;
  }

  static private boolean jj_3R_16() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_36()) {
    jj_scanpos = xsp;
    if (jj_3R_37()) return true;
    }
    if (jj_scan_token(LEFTBRACE_TKN)) return true;
    xsp = jj_scanpos;
    if (jj_3R_98()) jj_scanpos = xsp;
    if (jj_scan_token(RIGHTBRACE_TKN)) return true;
    return false;
  }

  static private boolean jj_3R_72() {
    if (jj_scan_token(SEQUENCE_TKN)) return true;
    return false;
  }

  static private boolean jj_3R_71() {
    if (jj_scan_token(SET_TKN)) return true;
    return false;
  }

  static private boolean jj_3R_68() {
    if (jj_scan_token(LEFTBRACE_TKN)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_82()) {
    jj_scanpos = xsp;
    if (jj_3R_83()) return true;
    }
    return false;
  }

  static private boolean jj_3_7() {
    if (jj_3R_17()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(27)) jj_scanpos = xsp;
    return false;
  }

  static private boolean jj_3R_50() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_71()) {
    jj_scanpos = xsp;
    if (jj_3R_72()) return true;
    }
    xsp = jj_scanpos;
    if (jj_3R_73()) jj_scanpos = xsp;
    if (jj_scan_token(OF_TKN)) return true;
    if (jj_3R_19()) return true;
    return false;
  }

  static private boolean jj_3R_45() {
    if (jj_3R_68()) return true;
    return false;
  }

  static private boolean jj_3R_44() {
    if (jj_3R_67()) return true;
    return false;
  }

  static private boolean jj_3R_43() {
    if (jj_3R_66()) return true;
    return false;
  }

  static private boolean jj_3R_42() {
    if (jj_3R_65()) return true;
    return false;
  }

  static private boolean jj_3R_97() {
    if (jj_scan_token(LEFTBRACE_TKN)) return true;
    return false;
  }

  static private boolean jj_3R_41() {
    if (jj_3R_64()) return true;
    return false;
  }

  static private boolean jj_3R_40() {
    if (jj_3R_63()) return true;
    return false;
  }

  static private boolean jj_3R_18() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_38()) {
    jj_scanpos = xsp;
    if (jj_3R_39()) {
    jj_scanpos = xsp;
    if (jj_3R_40()) {
    jj_scanpos = xsp;
    if (jj_3R_41()) {
    jj_scanpos = xsp;
    if (jj_3R_42()) {
    jj_scanpos = xsp;
    if (jj_3R_43()) {
    jj_scanpos = xsp;
    if (jj_3R_44()) {
    jj_scanpos = xsp;
    if (jj_3R_45()) return true;
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  static private boolean jj_3R_38() {
    if (jj_3R_61()) return true;
    return false;
  }

  static private boolean jj_3R_39() {
    if (jj_3R_62()) return true;
    return false;
  }

  static private boolean jj_3R_64() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(23)) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(13)) {
    jj_scanpos = xsp;
    if (jj_scan_token(12)) return true;
    }
    return false;
  }

  static private boolean jj_3R_113() {
    if (jj_3R_15()) return true;
    if (jj_scan_token(DOT_TKN)) return true;
    return false;
  }

  static private boolean jj_3R_105() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_113()) jj_scanpos = xsp;
    if (jj_3R_17()) return true;
    return false;
  }

  static private boolean jj_3R_106() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_8()) {
    jj_scanpos = xsp;
    if (jj_3R_114()) return true;
    }
    return false;
  }

  static private boolean jj_3R_79() {
    if (jj_3R_89()) return true;
    return false;
  }

  static private boolean jj_3_8() {
    if (jj_3R_18()) return true;
    return false;
  }

  static private boolean jj_3R_110() {
    if (jj_3R_17()) return true;
    return false;
  }

  static private boolean jj_3R_70() {
    if (jj_scan_token(LEFTBRACE_TKN)) return true;
    if (jj_3R_100()) return true;
    return false;
  }

  static private boolean jj_3R_100() {
    if (jj_3R_110()) return true;
    return false;
  }

  static private boolean jj_3R_49() {
    if (jj_scan_token(BIT_TKN)) return true;
    if (jj_scan_token(STRING_TKN)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_97()) jj_scanpos = xsp;
    return false;
  }

  static private boolean jj_3R_48() {
    if (jj_scan_token(INTEGER_TKN)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_70()) jj_scanpos = xsp;
    return false;
  }

  static private boolean jj_3R_78() {
    if (jj_3R_88()) return true;
    return false;
  }

  static private boolean jj_3_10() {
    if (jj_3R_19()) return true;
    return false;
  }

  static private boolean jj_3R_55() {
    if (jj_scan_token(ENUMERATED_TKN)) return true;
    if (jj_scan_token(LEFTBRACE_TKN)) return true;
    if (jj_3R_100()) return true;
    return false;
  }

  static private boolean jj_3R_56() {
    if (jj_scan_token(OCTET_TKN)) return true;
    if (jj_scan_token(STRING_TKN)) return true;
    return false;
  }

  static private boolean jj_3R_57() {
    if (jj_scan_token(OBJECT_IDENTIFIER_TKN)) return true;
    return false;
  }

  static private boolean jj_3R_58() {
    if (jj_scan_token(BOOLEAN_TKN)) return true;
    return false;
  }

  static private boolean jj_initialized_once = false;
  /** Generated Token Manager. */
  static public AsnParserTokenManager token_source;
  static SimpleCharStream jj_input_stream;
  /** Current token. */
  static public Token token;
  /** Next token. */
  static public Token jj_nt;
  static private int jj_ntk;
  static private Token jj_scanpos, jj_lastpos;
  static private int jj_la;
  static private int jj_gen;
  static final private int[] jj_la1 = new int[84];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
      jj_la1_init_2();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x0,0x0,0x0,0x10000,0x0,0x0,0x0,0x0,0x8000,0x0,0x0,0x8000,0x0,0x4000000,0x0,0x4000000,0x0,0x0,0x0,0xe0100100,0x0,0xc0000000,0x20100100,0x10000,0x10000,0x8000,0x803000,0x40000,0x800000,0x3000,0x0,0x40000,0x80000,0x40000,0x0,0xe0100100,0x8000,0x0,0x0,0xe0100100,0x0,0x0,0x0,0x3000,0x0,0x0,0x2000000,0x813e00,0x813e00,0x400000,0x400000,0x813e00,0x404000,0x0,0x4000,0x8000,0x0,0x40000,0x0,0x0,0x8000000,0x813e00,0x0,0x0,0x813e00,0x3000,0x0,0x0,0x3000,0x3000,0x3000,0x40000,0x3000,0x0,0x0,0x0,0x0,0x0,0x0,0x8000,0x813e00,0x0,0x0,0x0,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x0,0x300040,0x300040,0x0,0x1000000,0x2000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4c001ae,0x0,0x0,0x4c001ae,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x28,0x0,0x0,0x80000000,0x28,0x4c009ae,0x0,0x600,0x600,0x4c009ae,0x100040,0x100040,0x7000,0x0,0x7000,0x0,0x0,0xb8018004,0x20018004,0x0,0x0,0x40018004,0x0,0x800,0x0,0x0,0x0,0x0,0x200,0x200,0x0,0x18004,0x0,0x0,0x18004,0x0,0x18000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x18004,0x0,0x0,0x0,};
   }
   private static void jj_la1_init_2() {
      jj_la1_2 = new int[] {0x200000,0x0,0x0,0x0,0x0,0x0,0x340200,0x340200,0x0,0x340200,0x340200,0x0,0x340200,0x0,0x340200,0x0,0x300000,0x240200,0x240200,0x340200,0x200000,0x0,0x100000,0x0,0x0,0x0,0x300000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x300000,0x0,0x0,0x0,0x300000,0x0,0x0,0x0,0x300000,0x0,0x20,0x0,0x300183,0x300180,0x0,0x0,0x300180,0x0,0x4,0x0,0x0,0x100000,0x0,0x18,0x18,0x0,0x180,0x300000,0x200000,0x180,0x100000,0x0,0x180,0x100000,0x100000,0x300000,0x0,0x0,0x40200,0x40200,0x2000,0x4000,0x8000,0x10000,0x0,0x300180,0x20000,0x2000,0x4000,};
   }
  static final private JJCalls[] jj_2_rtns = new JJCalls[10];
  static private boolean jj_rescan = false;
  static private int jj_gc = 0;

  /** Constructor with InputStream. */
  public AsnParser(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public AsnParser(java.io.InputStream stream, String encoding) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser.  ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new AsnParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 84; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  static public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  static public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 84; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor. */
  public AsnParser(java.io.Reader stream) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser. ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new AsnParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 84; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  static public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 84; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor with generated Token Manager. */
  public AsnParser(AsnParserTokenManager tm) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser. ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 84; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(AsnParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 84; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  static private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      if (++jj_gc > 100) {
        jj_gc = 0;
        for (int i = 0; i < jj_2_rtns.length; i++) {
          JJCalls c = jj_2_rtns[i];
          while (c != null) {
            if (c.gen < jj_gen) c.first = null;
            c = c.next;
          }
        }
      }
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  static private final class LookaheadSuccess extends java.lang.Error { }
  static final private LookaheadSuccess jj_ls = new LookaheadSuccess();
  static private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) {
      int i = 0; Token tok = token;
      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
      if (tok != null) jj_add_error_token(kind, i);
    }
    if (jj_scanpos.kind != kind) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
    return false;
  }


/** Get the next Token. */
  static final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  static final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  static private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  static private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  static private int[] jj_expentry;
  static private int jj_kind = -1;
  static private int[] jj_lasttokens = new int[100];
  static private int jj_endpos;

  static private void jj_add_error_token(int kind, int pos) {
    if (pos >= 100) return;
    if (pos == jj_endpos + 1) {
      jj_lasttokens[jj_endpos++] = kind;
    } else if (jj_endpos != 0) {
      jj_expentry = new int[jj_endpos];
      for (int i = 0; i < jj_endpos; i++) {
        jj_expentry[i] = jj_lasttokens[i];
      }
      jj_entries_loop: for (java.util.Iterator<?> it = jj_expentries.iterator(); it.hasNext();) {
        int[] oldentry = (int[])(it.next());
        if (oldentry.length == jj_expentry.length) {
          for (int i = 0; i < jj_expentry.length; i++) {
            if (oldentry[i] != jj_expentry[i]) {
              continue jj_entries_loop;
            }
          }
          jj_expentries.add(jj_expentry);
          break jj_entries_loop;
        }
      }
      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
    }
  }

  /** Generate ParseException. */
  static public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[86];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 84; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
          if ((jj_la1_2[i] & (1<<j)) != 0) {
            la1tokens[64+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 86; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  static final public void enable_tracing() {
  }

  /** Disable tracing. */
  static final public void disable_tracing() {
  }

  static private void jj_rescan_token() {
    jj_rescan = true;
    for (int i = 0; i < 10; i++) {
    try {
      JJCalls p = jj_2_rtns[i];
      do {
        if (p.gen > jj_gen) {
          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
          switch (i) {
            case 0: jj_3_1(); break;
            case 1: jj_3_2(); break;
            case 2: jj_3_3(); break;
            case 3: jj_3_4(); break;
            case 4: jj_3_5(); break;
            case 5: jj_3_6(); break;
            case 6: jj_3_7(); break;
            case 7: jj_3_8(); break;
            case 8: jj_3_9(); break;
            case 9: jj_3_10(); break;
          }
        }
        p = p.next;
      } while (p != null);
      } catch(LookaheadSuccess ls) { }
    }
    jj_rescan = false;
  }

  static private void jj_save(int index, int xla) {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) {
      if (p.next == null) { p = p.next = new JJCalls(); break; }
      p = p.next;
    }
    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
  }

  static final class JJCalls {
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }

}
